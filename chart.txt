"use client";

import React, { useMemo } from "react";
import { format } from "date-fns";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  ResponsiveContainer,
  BarChart, Bar,
  LineChart, Line,
  AreaChart, Area,
  PieChart, Pie, Cell,
  CartesianGrid, XAxis, YAxis, Tooltip, Legend
} from "recharts";

const colors = {
  income: "#16a34a",   // green
  expense: "#ef4444",  // red
  net: "#3b82f6",      // blue
  accent: "#8b5cf6"    // purple-ish
};

export default function AccountCharts({ transactions = [] }) {
  // prepare -> group by day key (YYYY-MM-DD), compute income/expense per day and running balance
  const prepared = useMemo(() => {
    // make sure amounts are numbers and dates are Date objects
    const tx = (transactions || []).map((t) => ({
      ...t,
      amount: typeof t.amount === "number" ? t.amount : Number(t.amount || 0),
      dateObj: new Date(t.date)
    }));

    const map = new Map();
    tx.forEach((t) => {
      const key = t.dateObj.toISOString().slice(0, 10); // YYYY-MM-DD for sorting
      const label = format(t.dateObj, "MMM dd");
      if (!map.has(key)) map.set(key, { key, dateLabel: label, income: 0, expense: 0 });
      const entry = map.get(key);
      if (t.type === "INCOME") entry.income += t.amount;
      else entry.expense += t.amount;
    });

    const arr = Array.from(map.values()).sort((a, b) => new Date(a.key) - new Date(b.key));

    // compute running balance and net per day
    let running = 0;
    arr.forEach((e) => {
      const net = (e.income || 0) - (e.expense || 0);
      running += net;
      e.net = net;
      e.balance = running;
    });

    return arr;
  }, [transactions]);

  const totals = useMemo(() => {
    return prepared.reduce(
      (acc, d) => {
        acc.income += d.income || 0;
        acc.expense += d.expense || 0;
        return acc;
      },
      { income: 0, expense: 0 }
    );
  }, [prepared]);

  const pieData = [
    { name: "Income", value: totals.income },
    { name: "Expense", value: totals.expense }
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {/* Bar: Income vs Expense */}
      <Card>
        <CardHeader>
          <CardTitle>Daily Income vs Expense</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={prepared} margin={{ top: 8, right: 8, left: 0, bottom: 0 }}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="dateLabel" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Bar dataKey="income" name="Income" fill={colors.income} />
                <Bar dataKey="expense" name="Expense" fill={colors.expense} />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Line: Running Balance */}
      <Card>
        <CardHeader>
          <CardTitle>Running Balance</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={prepared} margin={{ top: 8, right: 8, left: -10, bottom: 0 }}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="dateLabel" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="balance" stroke={colors.net} strokeWidth={2} dot={false} />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Area: Income/Expense trends */}
      <Card>
        <CardHeader>
          <CardTitle>Income / Expense Trend (Area)</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <AreaChart data={prepared} margin={{ top: 8, right: 8, left: 0, bottom: 0 }}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="dateLabel" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Area type="monotone" dataKey="income" name="Income" stroke={colors.income} fill={colors.income} fillOpacity={0.15} />
                <Area type="monotone" dataKey="expense" name="Expense" stroke={colors.expense} fill={colors.expense} fillOpacity={0.10} />
              </AreaChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Pie: distribution */}
      <Card>
        <CardHeader>
          <CardTitle>Income vs Expense (Share)</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64 flex items-center justify-center">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={pieData}
                  dataKey="value"
                  nameKey="name"
                  cx="50%"
                  cy="50%"
                  innerRadius={56}
                  outerRadius={84}
                  label
                >
                  {pieData.map((entry, i) => <Cell key={`cell-${i}`} fill={i === 0 ? colors.income : colors.expense} />)}
                </Pie>
                <Tooltip />
                <Legend />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
















"use client";
import React, { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Check, Pencil, X } from "lucide-react";
import { toast } from "sonner";
import useFetch from "@/hooks/use-fetch";
import { updateBudget } from "@/actions/budget";

const BudgetProgress = ({ initialBudget, currentExpenses }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [newBudget, setNewBudget] = useState(
    initialBudget?.amount?.toString() || ""
  );

  const {
    loading: isLoading,
    fn: updateBudgetFn,
    data: updateBudgetData,
    error,
  } = useFetch(updateBudget);

  const percentUsed = initialBudget
    ? (currentExpenses / initialBudget.amount) * 100
    : 0;

  const handleUpdateBudget = async () => {
    const amount = parseFloat(newBudget);

    if (isNaN(amount) || amount <= 0) {
      toast.error("Please enter a valid amount");
      return;
    }

    await updateBudgetFn(amount);
  };

    const handleCancel = () => {
    setNewBudget(initialBudget?.amount?.toString() || "");
    setIsEditing(false);
  };

  useEffect(() => {
    if (updateBudgetData?.success) {
      setIsEditing(false);
      toast.success("Budget updated successfully");
    }
  }, [updateBudgetData]);

  useEffect(() => {
    if (error) {
      toast.error(error.message || "Failed to update budget");
    }
  }, [error]);

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <div className="flex-1">
          <CardTitle>Monthly Budget (Default Account)</CardTitle>
          <div className="flex items-center gap-2 mt-1">
            {isEditing ? (
              <div className="flex items-center gap-2">
                <Input
                  type="number"
                  value={newBudget}
                  onChange={(e) => setNewBudget(e.target.value)}
                  className="w-32"
                  placeholder="Enter amount"
                  autoFocus
                  disabled={isLoading}
                />
                <Button
                variant="ghost"
                size="icon"
                onClick={handleUpdateBudget}
                disabled={isLoading}
                >
                  <Check className="h-4 w-4 text-green-500" />
                </Button>
                <Button
                variant="ghost"
                size="icon"
                onClick={handleCancel}
                disabled={isLoading}
                >
                  <X className="h-4 w-4 text-red-500" />
                </Button>
              </div>
            ) : (
              <>
                <CardDescription>
                  {initialBudget
                    ? `$${currentExpenses.toFixed(2)} of $${initialBudget.amount.toFixed(
                        2
                      )} spent`
                    : "No budget set"}
                </CardDescription>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => setIsEditing(true)}
                  className="h-6 w-6"
                >
                  <Pencil className="h-4 w-4" />
                </Button>
              </>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent>
        {initialBudget && (
            <div className="space-y-2">
                <Progress value={percentUsed}
                extraStyles={`${
                    percentUsed >= 90
                    ? "bg-red-500"
                    : percentUsed >= 75
                    ? "bg-yellow-500"
                    : "bg-green-500"
                }`}
                />
                <p className = "text-xs text-muted-foreground text-right">
                    {percentUsed.toFixed(1)}% used
                </p>
            </div>
        )}
      </CardContent>
    </Card>
  );
};

export default BudgetProgress;






/*"use server";

import { db } from "@/lib/prisma";
import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";

export async function getCurrentBudget(accountId) {
  try {
    const { userId } = await auth();
    if (!userId) throw new Error("Unauthorized");

    // ðŸ§© Auto-create user if missing
    let user = await db.user.findUnique({ where: { clerkUserId: userId } });
    if (!user) {
      user = await db.user.create({ data: { clerkUserId: userId } });
    }

    // ðŸ§¾ Get user's budget
    const budget = await db.budget.findFirst({
      where: { userId: user.id },
    });

    // ðŸ“… Get current month's expenses
    const currentDate = new Date();
    const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
    const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);

    const expenses = await db.transaction.aggregate({
      where: {
        userId: user.id,
        type: "EXPENSE",
        date: { gte: startOfMonth, lte: endOfMonth },
        accountId,
      },
      _sum: { amount: true },
    });

    return {
      budget: budget ? { ...budget, amount: budget.amount.toNumber() } : null,
      currentExpenses: expenses._sum.amount ? expenses._sum.amount.toNumber() : 0,
    };
  } catch (error) {
    console.error("Error fetching budget:", error);
    throw error;
  }
}

export async function updateBudget(amount) {
  try {
    const { userId } = await auth();
    if (!userId) throw new Error("Unauthorized");

    // ðŸ§© Auto-create user if missing
    let user = await db.user.findUnique({ where: { clerkUserId: userId } });
    if (!user) {
      user = await db.user.create({ data: { clerkUserId: userId } });
    }

    // ðŸ’° Create or update budget
    const budget = await db.budget.upsert({
      where: { userId: user.id },
      update: { amount },
      create: { userId: user.id, amount },
    });

    revalidatePath("/dashboard");

    return {
      success: true,
      data: { ...budget, amount: budget.amount.toNumber() },
    };
  } catch (error) {
    console.error("Error updating budget:", error);
    return { success: false, error: error.message };
  }
}
*/










/*
  "use server";

  import { db } from "@/lib/prisma";
  import { auth } from "@clerk/nextjs/server";
  import { revalidatePath } from "next/cache";

  /* Utility to safely convert Prisma Decimal to number */
  function toNumberSafe(val) {
    if (val == null) return 0;
    if (typeof val === "number") return val;
    if (typeof val === "string") return Number(val) || 0;
    if (typeof val === "object" && typeof val.toNumber === "function") {
      try {
        return val.toNumber();
      } catch {
        return Number(String(val)) || 0;
      }
    }
    return Number(val) || 0;
  }

  /* -------------------------------
    ðŸ”· GET CURRENT BUDGET
  --------------------------------*/
  export async function getCurrentBudget(accountId) {
    try {
      const { userId } = await auth();
      if (!userId) throw new Error("Unauthorized");

      // Fetch or create user (with email!)
      let user = await db.user.findUnique({ where: { clerkUserId: userId } });

      if (!user) {
        user = await db.user.create({
          data: {
            clerkUserId: userId,
            email: "", // Clerk will override this once sign in is complete
          },
        });
      }

      // Fetch budget
      const budget = await db.budget.findFirst({
        where: { userId: user.id },
      });

      // Calculate expenses for current month
      const now = new Date();
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);

      const whereTxn = {
        userId: user.id,
        type: "EXPENSE",
        date: { gte: startOfMonth, lte: endOfMonth },
        ...(accountId ? { accountId } : {}),
      };

      const expensesAgg = await db.transaction.aggregate({
        where: whereTxn,
        _sum: { amount: true },
      });

      const currentExpenses = toNumberSafe(expensesAgg._sum.amount);

      return {
        initialBudget: budget
          ? {
              id: budget.id,
              userId: budget.userId,
              amount: toNumberSafe(budget.amount),
              lastAlertSent: budget.lastAlertSent,
              createdAt: budget.createdAt.toISOString(),
              updatedAt: budget.updatedAt.toISOString(),
            }
          : null,
        currentExpenses,
      };
    } catch (err) {
      console.error("Error fetching budget:", err);
      throw err;
    }
  }

  /* -------------------------------
    ðŸ”· UPDATE BUDGET
  --------------------------------*/
  export async function updateBudget(amount) {
    try {
      const { userId } = await auth();
      if (!userId) throw new Error("Unauthorized");

      const parsed = Number(amount);
      if (!Number.isFinite(parsed) || parsed <= 0) {
        return { success: false, error: "Invalid budget amount" };
      }

      // Ensure user exists
      let user = await db.user.findUnique({ where: { clerkUserId: userId } });

      if (!user) {
        user = await db.user.create({
          data: {
            clerkUserId: userId,
            email: "",
          },
        });
      }

      // Upsert budget
      const budget = await db.budget.upsert({
        where: { userId: user.id },
        update: { amount: parsed },
        create: { userId: user.id, amount: parsed },
      });

      // Get updated expenses for display
      const now = new Date();
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);

      const expensesAgg = await db.transaction.aggregate({
        where: {
          userId: user.id,
          type: "EXPENSE",
          date: { gte: startOfMonth, lte: endOfMonth },
        },
        _sum: { amount: true },
      });

      const currentExpenses = toNumberSafe(expensesAgg._sum.amount);

      // Trigger UI refresh
      revalidatePath("/dashboard");

      return {
        success: true,
        data: {
          initialBudget: {
            id: budget.id,
            userId: budget.userId,
            amount: toNumberSafe(budget.amount),
            lastAlertSent: budget.lastAlertSent,
            createdAt: budget.createdAt.toISOString(),
            updatedAt: budget.updatedAt.toISOString(),
          },
          currentExpenses,
        },
      };
    } catch (err) {
      console.error("Error updating budget:", err);
      return { success: false, error: err.message };
    }
  }
*/